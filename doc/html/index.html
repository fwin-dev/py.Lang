<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>py.Lang: Package description</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">py.Lang
   &#160;<span id="projectnumber">2.0.*</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Packages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Package description </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1>Summary of functionality</h1>
<p>This package provides a lot of miscellaneous things that probably should have been included in python's built-in library but weren't, including:</p>
<ul>
<li><a href="#functools">FuncTools</a>: Various function/method utilities/tools<ul>
<li><code>FuncTools.Abstraction.abstractmethod</code>: An abstract method that can be used with <code>@classmethod</code></li>
<li><code>FuncTools.timeIt</code>: Timing execution of a function with a decorator</li>
<li><code>FuncTools.getArgs</code>: A way to get the argument names and values of a function without using <code>**kwargs</code> or <code>*args</code></li>
</ul>
</li>
<li><a href="#classtools">ClassTools</a>: Various utilities/tools for working with classes. Also includes class patterns.<ul>
<li><code>ClassTools.vars</code>: Getting the variables of a class instance with <code>__slots__</code></li>
<li><code>ClassTools.Patterns</code>: A package with implementations of <a href="http://en.wikipedia.org/wiki/Software_design_pattern">class patterns</a><ul>
<li><code>ClassTools.Patterns.RegisteredInstances</code>: Easily keep track of all instances of a class</li>
<li><code>ClassTools.Patterns.Singleton</code>: Class bases (using metaclass) that implement the singleton pattern</li>
<li><code>ClassTools.Patterns.Multiton</code>: Class bases (using metaclass) that implement the multiton pattern</li>
<li><code>ClassTools.Patterns.StartEndWith</code>: Automatic support of the <code>with</code> statement by implementing only a start and end method</li>
</ul>
</li>
</ul>
</li>
<li><a href="#pypkgutil">PyPkgUtil</a>: Various module and package utilities/tools (Is a module built in? In what file is it? etc.)</li>
<li><a href="#struct">Struct</a>: Implementation of various structures to hold data<ul>
<li><code>Struct.LIFOstack</code>: LIFO/Stack</li>
<li><code>Struct.FrozenDict</code>: Frozen dictionary</li>
<li><code>Struct.OrderedSet</code>: Ordered set</li>
</ul>
</li>
<li><a href="#iter">Iter</a><ul>
<li><code>Iter.PeekableIterable</code>: A peekable iterator</li>
</ul>
</li>
<li><a href="#diff">Diff</a><ul>
<li><code>Diff.SequenceMatcher</code>: An improved differ, based on python's builtin <code>difflib.SequenceMatcher</code></li>
</ul>
</li>
<li><a href="#concurrency">Concurrency</a>: Unified API for locks, semaphores, etc., along with some useful tools/utilities<ul>
<li><code>Concurrency.Multiprocessing</code>: For dealing with multiple python processes<ul>
<li><code>Concurrency.Multiprocessing.decorators.processify</code>: Run a function in a separate process</li>
</ul>
</li>
<li><code>Concurrency.decorators.useLock</code>: Surround an entire function's execution in a lock</li>
<li><code>Concurrency.Threading</code>: A lock and semaphore using standard python threads</li>
<li><code>Concurrency.FileSystem.FileLock_ByFCNTL</code>: A lock using unix FCNTL file locking</li>
</ul>
</li>
<li><a href="#terminal">Terminal</a>: Utilities for improving terminal interaction with the user<ul>
<li><code>Terminal.askYesNo</code>: A simple way of asking user to respond with yes or no</li>
<li><code>Terminal.FormattedText</code>: Color text in the terminal. Also can do bold, underline, etc. depending on the terminal.</li>
<li><code>Terminal.Table</code>: Nicely prints column+row data in the terminal.</li>
<li><code>Terminal.ArgParser</code>: An improved ArgParser for parsing command line arguments</li>
</ul>
</li>
<li><a href="#events">Events</a>: Easy event handling with subscriptions+callbacks, including an API for event logging<ul>
<li><code>Events.Proxy</code>: Provides a super easy API for event subscription and callbacks</li>
<li><code>Events.Logging</code>: Skeleton classes for logging events to different destinations</li>
</ul>
</li>
<li><a href="#debugtracer">DebugTracer</a>: A poor man's debug tracer when a better tracer isn't available (for example, when running a python script over ssh without remote debugging)</li>
</ul>
<h1>Detailed functionality</h1>
<h2><a class="anchor" id="functools"></a>FuncTools</h2>
<p>A collection of function/method utilities/tools.</p>
<h3>An abstract class method</h3>
<p>The built in <code>abc.abstractmethod</code> decorator won't work if used in conjunction with a <code>classmethod</code> decorator. Use this abstract method decorator instead: </p>
<pre class="fragment">from Lang.FuncTools.Abstraction import abstractmethod

@classmethod
@abstractmethod
def myFunction(...):
    asdf
</pre><p>Make sure that <code>abstractmethod</code> comes after <code>classmethod</code>, else you will get: </p>
<pre class="fragment">`AttributeError: 'classmethod' object has no attribute '__name__'`
</pre><h3>Timing execution of a function</h3>
<p><code>timeIt</code> is a function decorator, so with the function you want to time, do: </p>
<pre class="fragment">from Lang.FuncTools import timeIt   

@timeIt
def myFunction(...):
    asdf
</pre><h3>Getting a function's arguments</h3>
<p>Python provides <code>**kwargs</code> and <code>*args</code> to get a dictionary or list of a function's arguments, but this makes it hard for IDEs and documentation generators to determine all possible arguments to the function. As an alternative to <code>**kwargs</code> or <code>*args</code>, you can specify all arguments explicitly and then use the <code>getArgs()</code> method: </p>
<pre class="fragment">from Lang.FuncTools import getArgs
def myFunc(arg1, arg2):
    allKwargs = getArgs()
</pre><p>This method uses python's built in <code>inspect</code> module to go up the stack and inspect arguments.</p>
<p>In the case above, <code>allKwargs</code> will be a dict of parameter names and associated values, similar to as if <code>**kwargs</code> was used.</p>
<p>To get a list of positional values instead, similar to <code>*args</code>, use <code>getArgs(useKwargFormat=False)</code>.</p>
<p>To get both kwargs and args, use: </p>
<pre class="fragment">args, kwargs = getArgs(useKwargFormat=None)
</pre><ul>
<li>Note that <code>cls</code> and <code>self</code> are automatically ignored for class methods and instance methods.</li>
<li>Note that if there is a question of whether an argument is an arg or a kwarg, then kwarg is preferred.</li>
</ul>
<h2><a class="anchor" id="classtools"></a>ClassTools</h2>
<p>Various utilities/tools for working with classes. Also includes class patterns.</p>
<h3>Getting the variables of a class instance with <b>slots</b></h3>
<p>This works the same as the built-in python function <code>vars()</code>, except it also works on slotted classes: </p>
<pre class="fragment">from Lang.ClassTools import vars
myClassVars = vars(MyClass())
</pre><h3>Patterns</h3>
<h4>Keeping track of class instances</h4>
<p>A common pattern in programming is the need to access all instantiations of a class for some reason. In static languages, this is often done in a factory, but in python, we can use metaclasses to implement this, and it gives a nicer interface for the programmer. For example: </p>
<pre class="fragment">from Lang.ClassTools.Patterns import RegisteredInstances

class Foo(RegisteredInstances):
    def __init__(self, value):
        super(Foo, self).__init__()
        self.value = value

a = Foo("asdf")
b = Foo("kjlh")
</pre><p>Now we can use the following to get an OrderedSet of all instances created: </p>
<pre class="fragment">fooInstances = Foo.getAllInstances()
</pre><p>The <code>RegisteredInstances</code> superclass also aims to support subclasses of your <code>Foo</code> in a nice way. For example, if we additionally define: </p>
<pre class="fragment">class Bar(Foo):
    pass
</pre><p>And then instantiate: </p>
<pre class="fragment">c = Bar("iuhl")
</pre><p>We'll get the following results:</p>
<ul>
<li>A call to <code>Foo.getAllInstances()</code> will return an OrderedSet of all 3 instances (2 of <code>Foo</code>, 1 of <code>Bar</code>) instantiated up to this point.</li>
<li>A call to <code>Foo.getAllClasses()</code> will return an iterable of 2 classes, <code>Foo</code> and <code>Bar</code>.</li>
<li>A call to <code>Bar.getAllInstances()</code> will return an OrderedSet of 1 instance of <code>Bar</code>.</li>
<li>A call to <code>Bar.getAllClasses()</code> will return an iterable of 1 class, <code>Bar</code>.</li>
</ul>
<h4>Singleton pattern</h4>
<p>A well known pattern is <a href="http://en.wikipedia.org/wiki/Singleton_pattern">the singleton pattern</a>. There are two implementations available in this package, depending on wanted behavior when your class's constructor is (incorrectly) called multiple times (aka <code>duplicate</code> instances); one implementation will raise an exception for the second instantiation attempt, and the other will simply ignore and discard the second attempt, and give the originally instantiated object back. Let's see these in action: </p>
<pre class="fragment">from Lang.ClassTools.Patterns import Singleton_OnDupRaiseException

class Foo(Singleton_OnDupRaiseException):
    def __init__(self, value):
        super(Foo, self).__init__()
        self.value = value
a = Foo(1)
b = Foo(2)  # an exception is raised
</pre><p>And the other singleton implementation: </p>
<pre class="fragment">from Lang.ClassTools.Patterns import Singleton_OnDupReturnExisting

class Foo(Singleton_OnDupReturnExisting):
    def __init__(self, value):
        super(Foo, self).__init__()
        self.value = value
a = Foo(1)
b = Foo(2)  # b actually holds the Foo(1) instance, and Foo(2) is not created
</pre><p>Note: Make sure the singleton superclass is the <b>first</b> in your MRO heirarchy.</p>
<p>The following methods would be available on <code>Foo</code>, similar to the "instance tracking" pattern, above. (See there for more details.) Differences are noted here:</p>
<ul>
<li><code>Foo.getAllClasses()</code>: Same behavior as above.</li>
<li><code>Foo.getAllInstances()</code>: Will return a dictionary with the key being the class, and the value being the singleton instance.</li>
</ul>
<h4>Multiton pattern</h4>
<p>There are two implementations of <a href="http://en.wikipedia.org/wiki/Multiton_pattern">the multiton pattern</a> aka "registry of singletons", similar to the singleton pattern above. Although wikipedia says a multiton is simply a singleton that keeps track of instances via key+value storage, this is very vague. In the py.Lang multiton implementation, each instance of the class must not be equal to another instance of the class (hence the name <code>Multiton_OneEquivalentInstance</code>), else either an exception is raised, or the existing instance, which is equal, is returned (hence the names <code>OnDupRaiseException</code>/<code>OnDupReturnExisting</code>, same as the singleton pattern). The uniqueness of the instance can be defined by the <code>__eq__</code> method. However, unlike the singleton pattern, since the instance must be created in order to compare using <code>__eq__</code>, be careful because the object's <code>__init__</code> method will always be called, regardless of whether the new instance is equal to an already-created instance. This could introduce an unintended side effect if not known in advance. If the new instance is not in fact valid, then it will be deleted (actually garbage collected because it will fall out of scope) after <code>__init__</code> and <code>__eq__</code> have been called.</p>
<p>The classes which can be inherited from are <code>Multiton_OneEquivalentInstance_OnDupRaiseException</code> and <code>Multiton_OneEquivalentInstance_OnDupReturnExisting</code>. Here is an example 2 instances allowed because the comparison is done by memory address, not using <code>__eq__</code>: </p>
<pre class="fragment">class Foo(Multiton_OneEquivalentInstance_OnDupRaiseException):
    def __init__(self, value):
        super(Foo, self).__init__()
        self.value = value
a = Foo(3)
b = Foo(3)
self.assertNotEqual(id(a), id(b))
</pre><p>And here's an example using <code>__eq__</code>: </p>
<pre class="fragment">class Foo(Multiton_OneEquivalentInstance_OnDupRaiseException):
    def __init__(self, value):
        super(Foo, self).__init__()
        self.value = value
    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.value == other.value
a = Foo(3)
b = Foo(3)  # will raise a DuplicateInstanceException
</pre><h4>StartEndWith pattern</h4>
<p>This pattern provides some nice functionality that just implementing <code>__enter__</code> and <code>__exit__</code> doesn't provide.</p>
<h5>Needing to manually enter and exit</h5>
<p>Find yourself implementing <code>__enter__</code> and <code>__exit__</code>, but still needing to manually call the entrance method and exit method sometimes? Yes, you can manually call <code>__enter__</code> or <code>__exit__</code> without using <code>with</code>, or you can define other methods like <code>start</code> and <code>end</code> which call <code>__enter__</code> and <code>__exit__</code>. The StartEndWith pattern gives you those nice looking <code>start</code> and <code>end</code> methods. You can even rename the methods by passing different method names into the constructor: </p>
<pre class="fragment">class Foo(StartEndWith):
    def __init__(self):
        super(Foo, self).__init__(methodName_start="begin", methodName_end="end")
    def _start(self, *args, **kwargs):
        &lt;your code to start something&gt;
    def _end(self, *args, **kwargs):
        &lt;your code to end something&gt;

a = Foo()
a.begin()
&lt;do something&gt;
a.end()
</pre><h5>Telling whether you've began or not</h5>
<p>StartEndWith defines an <code>isActive()</code> method, which returns whether or not you're inside the <code>with</code> statement (or have called <code>start()</code>). Continuing from the example above: </p>
<pre class="fragment">print(a.isActive())     # False
a.begin()
&lt;do something&gt;
print(a.isActive())     # True
a.end()
print(a.isActive())     # False
</pre><p>Or, using <code>with</code>: </p>
<pre class="fragment">with Foo() as a:
    print(a.isActive())     # True
</pre><h5>Starting more than once without ending</h5>
<p>If you'd like to be able to start something more than once without ending it, use <code>allowStartWhileRunning=True</code>. (Otherwise, an exception will be raised.) </p>
<pre class="fragment">class Foo(StartEndWith):
    def __init__(self):
        super(Foo, self).__init__(allowStartWhileRunning=True)
    def _start(self, *args, **kwargs):
        &lt;your code to start something&gt;
    def _end(self, *args, **kwargs):
        &lt;your code to end something&gt;

a.start()
a.start()
# this is also valid
a.end() # only need to call once
</pre><h5>Disposable resource</h5>
<p>If you only want to be able to call your start and end code (either via explicit calls or using <code>with</code>) once and never again, use <code>useOnce=True</code>: </p>
<pre class="fragment">class Foo(StartEndWith):
    def __init__(self):
        super(Foo, self).__init__(useOnce=True)
    def _start(self, *args, **kwargs):
        &lt;your code to start something&gt;
    def _end(self, *args, **kwargs):
        &lt;your code to end something&gt;

a = Foo()
a.begin()
&lt;do something&gt;
a.end()
a.begin()   # exception is raised

with a:     # exception is raised
    &lt;do something&gt;
</pre><h2><a class="anchor" id="pypkgutil"></a>PyPkgUtil</h2>
<p>Provides details about python packages and modules. Python can provide a lot of information about a package and a lot of different ways of loading packages, but the functions and code to accomplish this is scattered and sometimes not obvious. This <code>PkgUtil</code> module provides everything in one location. </p>
<pre class="fragment">from PyPkgUtil import PkgUtil
</pre><h3>Is it built in?</h3>
<p>A built in module is one who's source is not defined in a file. </p>
<pre class="fragment">PkgUtil.isBuiltin(moduleObj)
</pre><h3>Is it included in a stock python distibution?</h3>
<pre class="fragment">PkgUtil.isStock(moduleObj)
</pre><h3>Is an object a module or a package?</h3>
<pre class="fragment">PkgUtil.isModule(obj)
PkgUtil.isPackage(obj)
</pre><h3>Getting all modules and packages imported by a module</h3>
<pre class="fragment">PkgUtil.getImported_all(moduleObj, isRecursive)
</pre><p>Returns a flat list with all modules and packages.</p>
<h3>Getting all packages imported by a module</h3>
<pre class="fragment">PkgUtil.getImported_packages(moduleObj, isRecursive)
</pre><p>Returns a flat list.</p>
<h3>Full module path -&gt; Relative module path</h3>
<p>Convert the full file path of a module to a relative path, which can be used for importing: </p>
<pre class="fragment">relPath = PkgUtil.convert_fullPathToRelative(fullPath)
</pre><h3>Object -&gt; Full path</h3>
<p>Get the full file path of a module or package object: </p>
<pre class="fragment">fullPath = PkgUtil.convert_objectToFullPath(obj)
</pre><h3>Full path -&gt; Object</h3>
<p>Get the module or package object from a full path, aka import a module or package at the specified path: </p>
<pre class="fragment">obj = PkgUtil.convert_fullPathToObject(fullPath)
</pre><h3>Name string -&gt; Object</h3>
<p>Import an object by its name: </p>
<pre class="fragment">obj = PkgUtil.convert_nameToObject("moduleName")
</pre><h3>Object -&gt; Name string</h3>
<p>Get the name of a module or package: </p>
<pre class="fragment">name = PkgUtil.convert_objectToName(obj)
</pre><h2><a class="anchor" id="struct"></a>Struct</h2>
<p>Various structures for holding data.</p>
<h3>LIFO/Stack</h3>
<p>Python lists can be used as stacks, but they don't have the normal API that a stack does. </p>
<pre class="fragment">from Lang.Struct import LIFOstack
stack = LIFOstack()
stack.push("a")
element = stack.peek()
element = stack.pop()
</pre><h3>Frozen dictionary</h3>
<p>In the case where a hashable dictionary is needed, <code>FrozenDict</code> can be used. <code>FrozenDict</code> is just like a normal <code>dict</code> except it cannot be modified. </p>
<pre class="fragment">from Lang.Struct import FrozenDict
dict_ = FrozenDict({"asdf": 1, "jkl": 2})
</pre><h3>Ordered set</h3>
<p>The built-in python <code>set</code> is just like a <code>list</code>, except for 2 things:</p>
<ul>
<li>Sets can't contain duplicate elements</li>
<li>Sets are unordered</li>
</ul>
<p>However, there are some cases where an ordered set (aka a list with no duplicate elements) is desirable. For this, use the <code>OrderedSet</code> provided here, which provides a similar implementation compared to the built-in <code>set</code>, but also provides methods typically found in a list, such as <code>insert</code>/<code>insertAt</code>. Refer to the source and unit test for a list of all methods. </p>
<pre class="fragment">from Lang.Struct import OrderedSet
set_ = OrderedSet(range(1,10))
</pre><h2><a class="anchor" id="iter"></a>Iter</h2>
<h3>Peekable iterator</h3>
<p>Want to use an iterator for RAM usage concerns, but need to know the next element sometimes without advancing the iterator? Then this "peekable iterator" implementation is for you! Just wrap any iterable inside a <code>PeekableIterable</code>. That inner iterable is most likely a pure iterator itself (such as a generator), but it could also be anything that implements <code>__iter__</code>. </p>
<pre class="fragment">from Lang.Iter import PeekableIterable
def asdf():
    for i in range(0,10):
        yield i
nums = PeekableIterable(asdf())
print(nums.next())      # advances the iterator
print(nums.peek())      # peeks without advancing
print(nums.hasNext())   # checks if there's a next element
</pre><h2><a class="anchor" id="diff"></a>Diff</h2>
<h3>An improved differ</h3>
<p>This differ builds upon <code>difflib.SequenceMatcher</code> which can diff any python objects with <code>__eq__</code> implemented, contained within a list, tuple, etc. However, the built in class only provides methods for getting matching sets of indices which refer to matching elements, leaving you to infer which indices don't match. It also doens't give you direct access to elements that do or don't match. This differ adds all of that functionality. It also fixes:</p>
<ul>
<li>A bug: In the built in differ, subsequent calls to <code>get_matching_blocks()</code> will return results in a different format due to caching</li>
<li>Calculating the similarity ratio: The built in differ calculates this ratio taking both diff sides into account, but what's usually wanted is how much one side is similar/different compared to the other side: <code>(1 - ratio) / 2 + ratio</code></li>
</ul>
<p>Examples: </p>
<pre class="fragment">from Lang.Diff import SequenceMatcher
diff = SequenceMatcher(tuple("aebcdef"), tuple("abbcdgef"))
print(list(diff.get_matching_blocks()))
print(list(diff.get_mismatching_blocks()))
print(list(diff.get_matching_elems()))
print(list(diff.get_mismatching_elems()))

Prints the following:

[BlockMatch(a={index=0,size=1}, b={index=0,size=1}), BlockMatch(a={index=2,size=3}, b={index=2,size=3}), BlockMatch(a={index=5,size=2}, b={index=6,size=2})]
[BlockMismatch(a={index=1,size=1}, b={index=1,size=1}), BlockMismatch(a=None, b={index=5,size=1})]
[ElemMatch(a=('a',), b=('a',)), ElemMatch(a=('b', 'c', 'd'), b=('b', 'c', 'd')), ElemMatch(a=('e', 'f'), b=('e', 'f'))]
[ElemMismatch(a=('e',), b=('b',)), ElemMismatch(a=None, b=('g',))]
</pre><p>More functions are available, including:</p>
<ul>
<li><code>getmatching()</code> and <code>getmismatching()</code><ul>
<li>These return structures with <code>.block</code> and <code>.elems</code> attributes containing both block indices and the elems which the block refers to</li>
</ul>
</li>
<li><code>get_matching_elems_useOnce()</code> and <code>get_mismatching_elems_useOnce()</code><ul>
<li>These are the same as <code>get_matching_elems()</code> and <code>get_mismatching_elems()</code> except that they are generators instead of functions returning a list</li>
</ul>
</li>
</ul>
<h2><a class="anchor" id="concurrency"></a>Concurrency</h2>
<p>The <code>Concurrency</code> package provides a unified API for locks and semaphores, in addition to some useful utilities.</p>
<h3></h3>
<p>Using this function decorator will automatically cause the function to run inside a new python process: </p>
<pre class="fragment">from Concurrency.Multiprocessing.decorators import processify

@processify
def foo():
    &lt;do something&gt;
</pre><ul>
<li>Note that the code is not run in parallel to the current process, so this is not for gaining any speed.</li>
<li>Note that every argument and the return value must be picklable.</li>
</ul>
<h3>The unified API</h3>
<p>Different threading APIs and similar will generally have <code>lock</code> and <code>release</code> methods, along with possibly some other methods and functionality. A unified API was made in order to smooth over these differences and fill in functionality that was missing. This includes:</p>
<ul>
<li>Standardized method names</li>
<li>Standardized parameters for <code>lock</code> and <code>release</code> methods</li>
<li>Standardized parameters for lock/semaphore constructor</li>
</ul>
<h4></h4>
<p>Using this function decorator will automatically cause a lock to be acquired before executing the function, and released after the function exits: </p>
<pre class="fragment">from Concurrency.decorators import useLock

lockInstance = 
@useLock(lockInstance)
def foo():
    &lt;do something&gt;
</pre><h2><a class="anchor" id="events"></a>Events</h2>
<p>Easy event handling with subscriptions+callbacks, including an API for event logging.</p>
<h3>Events.Proxy</h3>
<p>For general event handling involving event subscription and listeners, there is a proxy API. The proxy receives an event (via a method call) and then calls any subscribers (aka receivers) to the event. In this implementation, a subscriber subscribes to all events, but only chooses to implement the methods for the events that it is interested in. The proxy checks each receiver to see if it has implemented the method, and if so, calls the method. All receivers can be forced to implement all methods by setting <code>errorOnMethodNotFound=True</code>. </p>
<pre class="fragment">from Lang.Events.Proxy import EventProxy, EventReceiver
proxy = EventProxy(errorOnMethodNotFound=False)

class Foo(EventReceiver):
    def someEvent(self, parametersOfEvent, moreParams=None):
        print("I was called")

foo = Foo()
proxy.addReceiver(foo)
proxy.someEvent("abc", moreParams=123)
</pre><h4>Handling uncaught exceptions</h4>
<p>When an uncaught exception happens, a special <code>notifyException</code> method will be called on each EventReceiver automatically, if the method is implemented, with the exception instance and a traceback instance as parameters. What you do with these parameters is up to you, but here is an example: </p>
<pre class="fragment">class Foo(EventReceiver):
    def notifyException(self, exceptionInstance, tracebackInstance):
        import traceback
        tracebackStr = "".join(traceback.format_tb(tracebackInstance))
        exceptionStr = str(exceptionInstance)
        print(tracebackStr)
        print()
        print(exceptionStr)
</pre><p>This idea can be combined with event logging, shown below. Also note that <code>errorOnMethodNotFound</code> has no effect on <code>notifyException</code>, as it is a special case.</p>
<h3>Event logging</h3>
<p>Python has decent built in logging, but it doesn't follow standard object-oriented concepts where methods represent actions, so the API is not ideal for recording different events in a heavily event based system, as there would need to be a special, separate call to the logging API for every event. The logging API in <code>Lang.Events.Logging</code> fixes this. It uses the event handling API shown above, where the <code>Logging</code> class is an <code>EventProxy</code>, and the loggers are <code>EventReceiver</code>s.</p>
<h4>Example using StdoutLogger</h4>
<p>This is a very simplistic example of logging to stdout: </p>
<pre class="fragment">from Lang.Events.Logging import Logging, StdoutLogger
log = Logging(StdoutLogger)
log.notifyMyEvent("details", "in", "arguments", "here")
</pre><h4>Example using a custom logger and/or multiple loggers</h4>
<p>When using multiple loggers, the function you call on the <code>Logging</code> instance will be called on every logger. </p>
<pre class="fragment">from Lang.Events.Logging import Logging, LoggerAbstract, StdoutLogger
class MyFileLog(LoggerAbstract):
    def __init__(self, filePath):
        super(MyLogger, self).__init__()
        self._filePath = filePath
    def notifyFolderCheck(self, folder):
        with open(self._filePath, "a") as file_:
            file_.write("Checking folder: " + folder)

log = Logging((StdoutLogger, MyFileLog))
log.notifyFolderCheck("folder/path/here")
</pre><h2><a class="anchor" id="terminal"></a>Terminal</h2>
<p>Utilities for improving terminal interaction with the user.</p>
<h3>Asking the user a question</h3>
<pre class="fragment">from Lang import Terminal
if Terminal.askYesNo("Do you like Star Trek?") == True:
    print("Awesome!")
else:
    print("Your nerd credit has been lowered")
</pre><h3>Using formatted text on the terminal</h3>
<pre class="fragment">from Lang.Terminal import FormattedText
</pre><p><code>FormattedText</code> returns a subclass of the built in python <code>str</code> type. It adds terminal formatting codes when the <code>str</code> function is called on it: </p>
<pre class="fragment">boldStr = str(FormattedText("I'm in bold", bold=True))
</pre><p><code>boldStr</code> will contain some funny looking characters which enable formatting, but these characters do not influence any other function of the string. For example: </p>
<pre class="fragment">char = boldStr[2]
</pre><p>will store <code>m</code> into <code>char</code>. Similarly, <code>len</code> and other functions will act the same as if the string were a direct instantiation of <code>str</code>.</p>
<p>Many more text attributes are available, including coloring - see the source for more information.</p>
<h3>Tables</h3>
<p>Printing tabular data to the terminal is very common. This implementation of a table has a couple extras with it. Here is an example: </p>
<pre class="fragment">from Terminal import Table
table = Table()
table.setColHeaders(("First Name", "Last Name Initial", "Number"))  # optional
table.setColMaxLens([None] * 3)         # enables automatic column sizing for the 3 columns
table.addRow(["Jesse", "C", str(1234)]) # explicitly convert all elements to strings
table.printLive()                       # prints all rows (and headers) that haven't been printed before
</pre><p>If another row is added to the table, another call to <code>printLive()</code> will only print only that new row.</p>
<h3>An improved ArgParser</h3>
<p>In addition to the plethora of features in <a href="https://docs.python.org/2.7/library/argparse.html">python's built-in argparse module</a>, a few more are added in here:</p>
<ul>
<li>Improved help formatting, similar to <code>man</code></li>
<li>Addition of 3 way booleans (<code>True</code>, <code>False</code>, <code>None</code>) and automatic handling of any other iterable type</li>
<li>Required named parameters - the built in ArgParser only supports required positional arguments and optional named parameters</li>
</ul>
<p>The new <code>ArgParser</code> uses the same interface as the old one, so see the built in <code>ArgParser</code> documentation.</p>
<p>Example: </p>
<pre class="fragment">from Lang.ArgParser import ArgParser
parser = ArgParser(argument_default=None, add_help=True, description="Adds a user to a linux machine")
parser.add_argument("username")
parser.add_argument("-p", "--password", required=False, help="Prompt for password if this is not given")
parser.add_argument("-H", "--create-home", type=Bool3Way, required=True,
    help="Controls home directory creation for user. None uses the default behavior which varies between machines.")
args = parser.parse_args()
</pre><h2><a class="anchor" id="debugtracer"></a>DebugTracer</h2>
<p>A poor man's debugger. Several arguments are available here. See the source for more details. </p>
<pre class="fragment">from Lang.DebugTracer import setTraceOn
setTraceOn()</pre> </div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Wed Apr 2 2014 16:39:28 for py.Lang by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>
