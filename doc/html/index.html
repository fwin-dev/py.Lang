<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>py.Lang: Package description</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">py.Lang
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.2 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Packages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Package description </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1>Summary of functionality</h1>
<p>This package provides a lot of miscellaneous things that probably should have been included in python's built-in library but weren't, including:</p>
<ul>
<li>Various function/method utilities/tools<ul>
<li>An abstract class method</li>
<li>Timing execution of a function with a decorator</li>
<li>A way to get the argument names and values of a function without using **kwargs or *args</li>
<li>A way to describe the argument and return types of functions, kind of similar to a statically typed language</li>
</ul>
</li>
<li>Various class utilities/tools<ul>
<li>Getting the variables of a class instance with <b>slots</b></li>
</ul>
</li>
<li>Various module and package utilities/tools (Is a module built in? In what file is it? etc.)</li>
<li>Implementation of various structures to hold data<ul>
<li>LIFO/Stack</li>
<li>Frozen dictionary</li>
<li>Ordered set</li>
</ul>
</li>
<li>A peekable iterator</li>
<li>An improved differ, based on <code>difflib.SequenceMatcher</code></li>
<li>An improved ArgParser for parsing command line arguments</li>
<li>A poor man's debug tracer when a better tracer isn't available (for example, when running a python script over ssh)</li>
<li>Easy event handling with subscription/listening, including event logging</li>
<li>Terminal/user interaction improvements</li>
</ul>
<h1>Detailed functionality</h1>
<h2>Function/method tools</h2>
<h3>An abstract class method</h3>
<p>The built in <code>abc.abstractmethod</code> decorator won't work if used in conjunction with a <code>classmethod</code> decorator. Use this abstract method decorator instead: </p>
<pre class="fragment">from Lang.FuncTools.Abstraction import abstractmethod

@classmethod
@abstractmethod
def myFunction(...):
    asdf
</pre><p>Make sure that <code>abstractmethod</code> comes after <code>classmethod</code>, else you will get: `AttributeError: 'classmethod' object has no attribute '<b>name</b>'`</p>
<h3>Timing execution of a function</h3>
<p><code>timeIt</code> is a function decorator, so with the function you want to time, do: </p>
<pre class="fragment">from Lang.FuncTools import timeIt   

@timeIt
def myFunction(...):
    asdf
</pre><h3>Getting a function's arguments</h3>
<p>Python provides <code>**kwargs</code> and <code>*args</code> to get a dictionary or list of a function's arguments, but this makes it hard for IDEs and documentation generators to determine all possible arguments to the function. As an alternative to <code>**kwargs</code> or <code>*args</code>, you can use the <code>getArgs()</code> method: </p>
<pre class="fragment">from Lang.FuncTools import getArgs
def myFunc(arg1, arg2):
    allArgs = getArgs()
</pre><p>This method uses python's built in <code>inspect</code> module to go up the stack and inspect arguments.</p>
<p>In the case above, <code>allArgs</code> will be a list of values, similar to as if <code>*args</code> was used. To get a dictionary of argument names and values instead, similar to <code>**kwargs</code>, use <code>getArgs(useKwargFormat=True)</code>.</p>
<p>Note that <code>cls</code> and <code>self</code> are automatically ignored for class methods and instance methods.</p>
<h3>Describing a function's argument and return types</h3>
<p>Some convenience classes are defined here that provide a thin, rough API for describing types. See the source in <code>Lang.Function</code> for details.</p>
<h2>Class tools</h2>
<h3>Getting the variables of a class instance with <b>slots</b></h3>
<p>This works the same as the built-in python function <code>vars()</code>, except it also works on slotted classes: </p>
<pre class="fragment">from Lang.ClassTools import vars
myClassVars = vars(MyClass())
</pre><h2>Details about python packages</h2>
<p>Python can provide a lot of information about a package and a lot of different ways of loading packages, but the functions and code to accomplish this is scattered. This <code>PkgUtil</code> module provides everything in one location. </p>
<pre class="fragment">from PyPkgUtil import PkgUtil
</pre><h3>Is it built in?</h3>
<p>A built in module is one who's source is not defined in a file. </p>
<pre class="fragment">PkgUtil.isBuiltin(moduleObj)
</pre><h3>Is it included in a stock python distibution?</h3>
<pre class="fragment">PkgUtil.isStock(moduleObj)
</pre><h3>Is an object a module or a package?</h3>
<pre class="fragment">PkgUtil.isModule(obj)
PkgUtil.isPackage(obj)
</pre><h3>Getting all modules and packages imported by a module</h3>
<pre class="fragment">PkgUtil.getSubs(moduleObj, isRecursive)
</pre><p>Returns a flat list with all modules and packages.</p>
<h3>Getting all packages imported by a module</h3>
<pre class="fragment">PkgUtil.getSubPackages(moduleObj, isRecursive)
</pre><p>Returns a flat list.</p>
<h3>Full module path -&gt; Relative module path</h3>
<p>Convert the full file path of a module to a relative path, which can be used for importing: </p>
<pre class="fragment">relPath = PkgUtil.convert_fullPathToRelative(fullPath)
</pre><h3>Object -&gt; Full path</h3>
<p>Get the full file path of a module or package object: </p>
<pre class="fragment">fullPath = PkgUtil.convert_objectToFullPath(obj)
</pre><h3>Full path -&gt; Object</h3>
<p>Get the module or package object from a full path, aka import a module or package at the specified path: </p>
<pre class="fragment">obj = PkgUtil.convert_fullPathToObject(fullPath)
</pre><h3>Name string -&gt; Object</h3>
<p>Import an object by its name: </p>
<pre class="fragment">obj = PkgUtil.convert_nameToObject("moduleName")
</pre><h3>Object -&gt; Name string</h3>
<p>Get the name of a module or package: </p>
<pre class="fragment">name = PkgUtil.convert_objectToName(obj)
</pre><h2>Structures</h2>
<h3>LIFO/Stack</h3>
<p>Python lists can be used as stacks, but they don't have the normal API that a stack does. </p>
<pre class="fragment">from Lang.Struct import LIFOstack
stack = LIFOstack()
stack.push("a")
element = stack.peek()
element = stack.pop()
</pre><h3>Frozen dictionary</h3>
<p>In the case where a hashable dictionary is needed, <code>FrozenDict</code> can be used. <code>FrozenDict</code> is just like a normal <code>dict</code> except it cannot be modified. </p>
<pre class="fragment">from Lang.Struct import FrozenDict
dict_ = FrozenDict({"asdf": 1, "jkl": 2})
</pre><h3>Ordered set</h3>
<p>The built-in python <code>set</code> is just like a <code>list</code>, except for 2 things:</p>
<ul>
<li>Sets can't contain duplicate elements</li>
<li>Sets are unordered</li>
</ul>
<p>However, there are some cases where an ordered set (aka a list with no duplicate elements) is desirable. For this, use the <code>OrderedSet</code> provided here, which provides a similar implementation compared to the built-in <code>set</code>, but also provides methods typically found in a list, such as <code>insert</code>/<code>insertAt</code>. Refer to the source and unit test for a list of all methods. </p>
<pre class="fragment">from Lang.Struct import OrderedSet
set_ = OrderedSet(range(1,10))
</pre><h2>Peekable iterator</h2>
<p>Want to use an iterator for RAM usage concerns, but need to know the next element sometimes without advancing the iterator? Then this "peekable iterator" implementation is for you! Just wrap any iterable inside a <code>PeekableIterable</code>. That inner iterable is most likely a pure iterator itself (such as a generator), but it could also be anything that implements <code>__iter__</code>. </p>
<pre class="fragment">from Lang.Iter import PeekableIterable
def asdf():
    for i in range(0,10):
        yield i
nums = PeekableIterable(asdf())
print(nums.next())      # advances the iterator
print(nums.peek())      # peeks without advancing
print(nums.hasNext())   # checks if there's a next element
</pre><h2>Improved differ</h2>
<p>This differ builds upon <code>difflib.SequenceMatcher</code> which can diff any python objects with <code>__eq__</code> implemented, contained within a list, tuple, etc. However, the built in class only provides methods for getting matching sets of indicies which refer to matching elements, leaving you to infer which indicies don't match. It also doens't give you direct access to elements that do or don't match. This differ adds all of that functionality. It also fixes:</p>
<ul>
<li>A bug in the built in differ where subsequent calls to <code>get_matching_blocks()</code> returns results in a different format</li>
<li><p class="startli">Calculating the similarity ratio: The built in differ calculates this ratio taking both diff sides into account, but what's usually wanted is how much one side is similar/different compared to the other side, i.e. <code>(1 - ratio) / 2 + ratio</code></p>
<p class="startli">from Lang.Diff import SequenceMatcher diff = SequenceMatcher(tuple("aebcdef"), tuple("abbcdgef")) print(list(diff.get_matching_blocks())) print(list(diff.get_mismatching_blocks())) print(list(diff.get_matching_elems())) print(list(diff.get_mismatching_elems()))</p>
<p class="startli">Prints the following: [BlockMatch(a={index=0,size=1}, b={index=0,size=1}), BlockMatch(a={index=2,size=3}, b={index=2,size=3}), BlockMatch(a={index=5,size=2}, b={index=6,size=2})] [BlockMismatch(a={index=1,size=1}, b={index=1,size=1}), BlockMismatch(a=None, b={index=5,size=1})] [ElemMatch(a=('a',), b=('a',)), ElemMatch(a=('b', 'c', 'd'), b=('b', 'c', 'd')), ElemMatch(a=('e', 'f'), b=('e', 'f'))] [ElemMismatch(a=('e',), b=('b',)), ElemMismatch(a=None, b=('g',))]</p>
</li>
</ul>
<p>More functions are available, including:</p>
<ul>
<li><code>getmatching()</code> and <code>getmismatching()</code><ul>
<li>These return structures with <code>.block</code> and <code>.elems</code> attributes containing both block indicies and the elems which the block refers to</li>
</ul>
</li>
<li><code>get_matching_elems_useOnce()</code> and <code>get_mismatching_elems_useOnce()</code><ul>
<li>These are the same as <code>get_matching_elems()</code> and <code>get_mismatching_elems()</code> except that they are generators instead of functions returning a list</li>
</ul>
</li>
</ul>
<h2>An improved ArgParser</h2>
<p>In addition to the plethora of features in python's built in <code>ArgParser</code>, a few more are added in here:</p>
<ul>
<li>Improved help formatting, similar to <code>man</code></li>
<li>3 way boolean (<code>True</code>, <code>False</code>, <code>None</code>)</li>
<li>Required named parameters - the built in ArgParser only supports required positional arguments and optional named parameters</li>
</ul>
<p>The new <code>ArgParser</code> uses the same interface as the old one, so see the built in <code>ArgParser</code> documentation.</p>
<p>Example: </p>
<pre class="fragment">from Lang.ArgParser import ArgParser
parser = ArgParser(argument_default=None, add_help=True, description="Adds a user to a linux machine")
parser.add_argument("username")
parser.add_argument("-p", "--password", required=False, help="Prompt for password if this is not given")
parser.add_argument("-H", "--create-home", type=Bool3Way, required=True,
    help="Controls home directory creation for user. None uses the default behavior which varies between machines.")
args = parser.parse_args()
</pre><h2>Poor man's debugger</h2>
<p>Several arguments are available here. See the source for more details. </p>
<pre class="fragment">from Lang.DebugTracer import setTraceOn
setTraceOn()
</pre><h2>Event handling</h2>
<p>For general event handling with event subscription and listeners, there is a proxy API. The proxy receives an event (via a method call) and then calls any subscribers (aka receivers) to the event. In this implementation, a subscriber subscribes to all events, but only chooses to implement the methods for the events that it is interested in. The proxy checks each receiver to see if it has implemented the method, and if so, calls the method. All receivers can be forced to implement all methods by setting <code>errorOnMethodNotFound=True</code>. </p>
<pre class="fragment">from Lang.Events.Proxy import EventProxy, EventReceiver
proxy = EventProxy(errorOnMethodNotFound=False)

class Foo(EventReceiver):
    def someEvent(self, parametersOfEvent, moreParams=None):
        print("I was called")

foo = Foo()
proxy.addReceiver(foo)
proxy.someEvent("abc", moreParams=123)
</pre><h2>Handling uncaught exceptions</h2>
<p>When an uncaught exception happens, a special <code>notifyException</code> method will be called on each EventReceiver automatically, if the method is implemented, with the exception instance and a traceback instance as parameters. What you do with these parameters is up to you, but here is an example: </p>
<pre class="fragment">class Foo(EventReceiver):
    def notifyException(self, exceptionInstance, tracebackInstance):
        import traceback
        tracebackStr = "".join(traceback.format_tb(tracebackInstance))
        exceptionStr = str(exceptionInstance)
        print(tracebackStr)
        print()
        print(exceptionStr)
</pre><p>This idea can be combined with event logging, shown below. Also note that <code>errorOnMethodNotFound</code> has no effect on <code>notifyException</code>, as it is a special case.</p>
<h3>Event logging</h3>
<p>Python has decent built in logging, but it doesn't follow standard object-oriented concepts where methods represent actions, so the API is not ideal for recording different events in a heavily event based system, as there would need to be a special, separate call to the logging API for every event. The logging API in <code>Lang.Events.Logging</code> fixes this. It uses the event handling API shown above, where the <code>Logging</code> class is an <code>EventProxy</code>, and the loggers are <code>EventReceiver</code>s.</p>
<h4>Example using StdoutLogger</h4>
<p>This is a very simplistic example of logging to stdout: </p>
<pre class="fragment">from Lang.Events.Logging import Logging, StdoutLogger
log = Logging(StdoutLogger)
log.notifyMyEvent("details", "in", "arguments", "here")
</pre><h4>Example using a custom logger and/or multiple loggers</h4>
<p>When using multiple loggers, the function you call on the <code>Logging</code> instance will be called on every logger. </p>
<pre class="fragment">from Lang.Events.Logging import Logging, LoggerAbstract, StdoutLogger
class MyFileLog(LoggerAbstract):
    def __init__(self, filePath):
        super(MyLogger, self).__init__()
        self._filePath = filePath
    def notifyFolderCheck(self, folder):
        with open(self._filePath, "a") as file_:
            file_.write("Checking folder: " + folder)

log = Logging((StdoutLogger, MyFileLog))
log.notifyFolderCheck("folder/path/here")
</pre><h2>Terminal improvements</h2>
<h3>Asking the user a question</h3>
<pre class="fragment">from Lang import Terminal
if Terminal.askYesNo("Do you like Star Trek?") == True:
    print("Awesome!")
else:
    print("Your nerd credit has been lowered")
</pre><h3>Using formatted text on the terminal</h3>
<pre class="fragment">from Lang.Terminal import FormattedText
</pre><p><code>FormattedText</code> returns a subclass of the built in python <code>str</code> type. It adds terminal formatting codes when the <code>str</code> function is called on it: </p>
<pre class="fragment">boldStr = str(FormattedText("I'm in bold", bold=True))
</pre><p><code>boldStr</code> will contain some funny looking characters which enable formatting, but these characters do not influence any other function of the string. For example: </p>
<pre class="fragment">char = boldStr[2]
</pre><p>will store <code>m</code> into <code>char</code>. Similarly, <code>len</code> and other functions will act the same as if the string were a direct instantiation of <code>str</code>.</p>
<p>Many more text attributes are available, including coloring - see the source for more information.</p>
<h3>Tables</h3>
<p>Printing tabular data to the terminal is very common. This implementation of a table has a couple extras with it. Here is an example: </p>
<pre class="fragment">from Terminal import Table
table = Table()
table.setColHeaders(("First Name", "Last Name Initial", "Number"))  # optional
table.setColMaxLens([None] * 3)         # enables automatic column sizing for the 3 columns
table.addRow(["Jesse", "C", str(1234)]) # explicitly convert all elements to strings
table.printLive()                       # prints all rows (and headers) that haven't been printed before
</pre><p>If another row is added to the table, another call to <code>printLive()</code> will only print only that new row. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Mon Apr 29 2013 11:41:45 for py.Lang by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.2 </li>
  </ul>
</div>
</body>
</html>
